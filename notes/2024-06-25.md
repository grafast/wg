# Gra*fast* Working Group, 25th June 2024

**Agenda:** https://github.com/grafast/wg/blob/main/agendas/2024-06-25.md

1. Confirm agreement
   to [Grafast contribution agreement](https://github.com/grafast/wg/blob/main/AGREEMENT.md)
2. Introduction of attendees
3. Status update
4. Partial planning for Polymorphism
5. Exportable plans for efficiency/caching
6. [Eradicating eval](https://github.com/graphile/crystal/issues/2060)

**Attendees**

Benjie Gillam  
Maik Diepenbroek  
Teo S  
Ian Stewart  

**Apologies**

Jem G  

## 3. Status Update (Benjie) 

Since the last working group in September 2023, global dependices and early exit have both been addressed. 

**Global dependencies**  

[See last WG for an overview of the problem](https://github.com/grafast/wg/blob/68ae0d3f2d363a8949d2d1b63a4650ecc1077297/notes/2023-10-24.md#4-global-dependencies-proposal-benjie)  
The solution has been reached: "unary" values  
If Gra*fast* knows there will always be _exactly one value for a step_, then that step will be a "unary" step. 
Arguments, variables, and context are always unary. 

**Early exit**  

[See last WG for an overview of the problem](https://github.com/grafast/wg/blob/68ae0d3f2d363a8949d2d1b63a4650ecc1077297/notes/2023-10-24.md#5-early-exit-proposal-benjie)    
The solution is a new step: `inhibitOnNull()`  
`$a = inhibitOnNull($b)`: if `$b` is null then anything that depends on `$a` will automatically be null (and won't be evaluated).  
`assertNotNull($b)`: raises an exception if `$b` is null (thereby preventing future steps executing).  
`$b = trap($a, TRAP_INHIBITED, { valueForInhibited: "EMPTY_LIST" })` copies `$a` unless it's inhibited, in which case it becomes `[]`.  
This could also, in theory, trap errors - though there is a bug in this at the moment. Internally, we re-wrote how errors and nulls are handled - we now
use bit masks to flag the values in the system to flag if they are an error, null, inhibited or not.  
By default, nulls are accepted but errors and inhibited values are not; Trap can be configured to accept the different flags.

**Error handling has evolved**

Grafast had had 5 major rewrites, many ways of handling errors. We now track errors via a bit in the bitmask. Errors can now be any value, and determining 
if something is an error is a bitwise operation.  

Error handling was inconsistent (and potentially incoherent). Errors can now be `trap()`'d, making error handling for more consistent.  

**Misc Updates**

- New `polymorphicBranch()` step. [See https://grafast.org/grafast/step-library/standard-steps/polymorphicBranch](https://grafast.org/grafast/step-library/standard-steps/polymorphicBranch
). 
- New `sideEffect()` step. Essentially the same as `lambda()` but expected to make side effects.   
- `loadOne()` and `loadMany()` are faster: Replaced `setTimeout(cb, 0)` with `process.nextTick(cb)` which massively improved throughput.  
- New `nodeIdFromNode()` helper  
- `grafast.hooks` is now middleware   
- `$step.get(fieldName)` default introduced  
- `execute()` signature has changed - see [err.red/gev2](https://err.red/gev2)   
- `grafast()` signature has changed - all options are accepted via configuration object now rather than additional parameters (older method has 
been deprecated but still supported)  

## 4. Partial planning for Polymorphism (Benjie)

Planning of polymorphism can be expensive as every possible type is enumerated and planned - including any polymorphic child fields, resulting in
polymorphic planning becomming a significant undertaking. The current recommendation is to only use Grafast with persisted operations (trusted
documents) to mitigate this planning, plus there's a planning timeout.  

The proposed solution is to plan up to the boundary of the polymorphism and stop, then at runtime work out which polymorphic fields actually need to be planned. 

## 5. Exportable plans for efficiency/caching (Benjie)


## 6. Eradicating eval (Benjie)



## Conclusions

